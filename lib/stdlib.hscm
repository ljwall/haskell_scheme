(define (not x)
  (if x #f #t))

(define (list . args) args)

(define (id x) x)

(define (flip fn)
  (lambda (a b) (fn b a)))

(define (curry fn x)
  (lambda xs (apply fn (cons x xs))))

(define (compose f g)
  (lambda (x) (f (g x)) ))

(define (odd? num) (= (mod num 2) 1))
(define (even? num) (= (mod num 2) 0))

(define head car)
(define tail cdr)

(define (null? lst) (eqv? '() lst))

(define (foldr fn init xs)
  (if (null? xs)
    init
    (fn (head xs) (foldr fn init (tail xs))) ))

(define (foldl fn init xs)
  (if (null? xs)
    init
    (foldl fn (fn init (head xs)) (tail xs))))

(define (reverse xs) (foldl (flip cons) '() xs))

(define (unfold func init predicate)
  (if (predicate init)
    (cons init (unfold func (func init) predicate))
    '()))

(define (range from to . step)
  (define s (if (null? step) 1 (head step)))
  (unfold (curry + s) from (curry > to) ))

(define (map fn xs)
  (foldr (lambda (x acc) (cons (fn x) acc)) '() xs))

(define (filter predicate xs)
  (define (fn x acc)
    (if (predicate x)
      (cons x acc)
       acc))
  (foldr fn '() xs))
